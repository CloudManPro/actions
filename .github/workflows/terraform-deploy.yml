name: Dynamic Pro-Level Pipeline

on:
  push:
    paths: ['**/manifest.json']
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detectar Manifest e Ação
        id: flow
        run: |
          # 1. Detecta qual manifest.json mudou
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          
          # Fallback para Re-run (procura o primeiro manifesto que encontrar)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1 | sed 's|./||')
          fi

          if [ -z "$MANIFEST_PATH" ]; then
            echo "ERRO: Nenhum manifest.json encontrado!"
            exit 1
          fi

          echo "Manifesto encontrado em: $MANIFEST_PATH"

          # 2. Extrai a Ação
          ACTION=$(jq -r '.action' "$MANIFEST_PATH")
          
          # 3. Extrai a Pipeline e inverte se for Destroy
          if [ "$ACTION" == "destroy" ]; then
            STAGES=$(jq -c '.pipeline | reverse | .[]' "$MANIFEST_PATH")
          else
            STAGES=$(jq -c '.pipeline[]' "$MANIFEST_PATH")
          fi

          # 4. Salva as saídas para os próximos passos
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "stages_list=$(echo $STAGES | tr '\n' ' ')" >> $GITHUB_OUTPUT
          
          echo "========================================"
          echo "AÇÃO: $ACTION"
          echo "PIPELINE: $STAGES"
          echo "========================================"

      - name: Configurar AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::952133486861:role/CloudManActions
          aws-region: us-east-1

      - uses: hashicorp/setup-terraform@v3

      - name: Executar Pipeline
        run: |
          ACTION="${{ steps.flow.outputs.action }}"
          STAGES='${{ steps.flow.outputs.stages_list }}'
          
          for group in $STAGES; do
            # Extrai os sub-itens do grupo (ex: vpc ou subnet1 subnet2)
            items=$(echo $group | jq -r '.[]')
            
            echo "::group::Processando Estágio: $items"
            
            for item in $items; do
              (
                echo ">>> Iniciando Terraform em: $item"
                terraform -chdir=$item init -backend-config="key=$item/terraform.tfstate" -reconfigure > /dev/null
                terraform -chdir=$item $ACTION -auto-approve
              ) & 
            done

            wait # Espera o grupo paralelo terminar antes de ir para o próximo estágio sequencial
            echo "::endgroup::"
          done
